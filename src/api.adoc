[[cx_api]]
== CX API

[WARNING]
.This section is in the link:http://riscv.org/spec-state[Development state].
====
This section is actively being written and subsections and detail
are changing daily. Please check back regularly for updates.
====

=== Introduction (non-normative)

This section specifies the _CX API_ (application programming interface)
that _CX libraries_ use to discover, select, use, share, and manage
composable custom extensions.

The CX API is implemented, in each environment, by a _CX Runtime_,
typically in concert with a CX-aware operating system.

The API provides common, uniform CX programming services, including CX
naming, discovery, versioning, use, state models, error handling, and
resource management.

The CX API promotes a _CX programming model_ providing dependable
composition of CX libraries, decentralized development, and stable CX
library binaries, for modern software ecosystems and applications.

==== Foundational assumptions

The CX Framework supports independently authored and versioned CX
libraries.

CX libraries must support systems and hardware with and without any
given CX.

CX library _binaries_ are stable, meaning they need not be recompiled
for different systems that implement different sets of CXs.

CX libraries employ a dynamic discovery model, requesting access to one
or more CXs, and coping when the requested CX is not available, perhaps by
falling back to request a different CX or CX version, or by erroring out.

A given CX library employs a coding pattern of _discover_, _select_,
_use_. It first discovers (requests) a given CX. Then, if available,
it always selects a CX prior to issuing its custom instructions.

==== Other requirements and desiderata

Language and compiler support is optional: it must be possible to use a CX
and its CX libraries without changing the compiler / compilation system.

Similarly the CX programming model that the CX API promotes must make
it possible to add a new CX and its libraries to a system without having
to change the operating system / kernel / RTOS.

The CX API must support modern programming models including threads,
task parallel, async/await, and coroutine models.

The CX API must support arbitrary composition of CX libraries. Mutiple CX
libraries may use the same CX, and CX libraries may nest calls to other
CX libraries.

The CX API must promote longevity across decades, anticipate and support
forward compatibility, for arbitrary mixes of old and new CX libraries
running on old and new processors, with old and new versions of given
CXs. With long lived interop standards, and rich software ecosystems,
there can be no "just recompile everything" do-over.

The CX API should be as simple and minimalist as possible.

The CX API and programming model should promote efficient programming
idioms.

To promote source code portability of _purely computational_ CX libraries,
the CX API itself should not exhibit operating system dependencies.

==== CX state isolation models

Different CXs will be designed to exhibit different state isolation models.
The CX API supports at least three major categories of such models:

1. A _stateless_ CX requires no additional state. CX custom instructions
access only the pre-existing hart state.

2. A _shared state_ CX assumes there may be zero or one instance of CX
state per hart. Its custom instructions may access this state and their
behavior may depend upon it. It has a specific _sharing model_, uniformly
employed by its various (independenly authored) CX libraries, specifying
the discipline used by all such CX libraries to dependably share the one
instance of the CX state among them. For example, a CX's sharing model
might be caller-save, callee-save, always-initialize, or even something
finer grained that is specific to that CX's state.

3. An _exclusive state_ CX assumes there may be zero or more instances of
CX state per hart. Its custom instructions may access the one currently
selected instance state and their behavior may depend upon it. An
exclusive state CX library may rely upon its sole ownership of the CX
instance, and therefore need not save/restore its state across
invocations. (TODO: provide additional specificity on this.)

==== CX state isolation models vs. user thread context state

A subtle and important consideration (for some environments) is whether a
given CX instance is to be considered part of the _user_ thread context,
such that it is automatically saved by, e.g., the user C/C++ runtime
library in `setjmp's jmp_buf` structure, or in `makecontext's ucontext_t`
structure.

It is appealing to try to couple this behavior to the CX's state model,
e.g., shared state CXs are preserved in user thread contexts while
exclusive state CXs are _not_ -- but it may be useful to keep these
decoupled and orthogonal. Consider the four cases.

1. Shared state CX instance, included in user thread contexts: this
follows current practice for RISC-V extensions. (REVIEW: is this true
for -V vector state on Linux / glibc? -- is it automatically added to
`ucontext_t` upon use?)

2. Shared state CX instance, _not_ included in user thread contexts.
If a new shared state CX (e.g., an AME-like CX) has an enormous
memory footprint, it may be performance-prohibitive to include it in
user context records.

3. Exclusive state CX instance, _not_ included in user thread contexts.
This is the expected way to use a private state CX. It is treated as
an owned _hardware object_, much like another heap allocated object,
a private resource explicitly managed by the specific CX library.

4. Exclusive state CX instance, included in user thread contexts.
It is unclear if there is a compelling use case for this combination.

Distinguishing between case 1 and 2 seems useful, so this draft
specification supports decoupling these behaviors (see
`cx_open_ucontext` below).

==== User thread context includes the thread's current CX selection

Note the distinction between CX Framework state, i.e., thread's
_current CX (instance) selection_, and various CX instances' state.

The thread's current CX selection (see `cx_select` and `cx_get_sel` below),
is part of the user thread state. On Linux/glibc it is preserved in
user thread contexts objects, including `ucontext_t` and `jmp_buf`.

=== CX API

==== API

```C
#include <stddef.h>
#include <stdint.h>

typedef struct uuid {
    uint8_t bytes[16];
} uuid_t;

typedef unsigned long cx_sel_t;  // XLEN-sized
static const cx_sel_t cx_sel_invalid = ~0UL;
static const cx_sel_t cx_sel_builtin = 0UL;

typedef enum cx_open_flags {
    cx_open_shared    = 0,
    cx_open_exclusive = 1,
    cx_open_ucontext  = 2
} cx_open_flags_t;

cx_sel_t cx_open(const uuid_t* puuid, cx_open_flags_t flags);
int      cx_close(cx_sel_t sel);
bool     cx_valid(cx_sel_t sel);
cx_sel_t cx_get_sel(void);
cx_sel_t cx_select(cx_sel_t sel);
ssize_t  cx_save(void* pv, size_t size);
ssize_t  cx_restore(void* pv, size_t size);
```

==== Types

`uuid_t` is a 128b _Universally Unique ID_ (RFC 9562). CX libraries
(esp. CX library binaries) employ CX UUIDs to canonically and stably
identify CXs across time and space.

A CX UUID is the unique and canonical name of a given CX (i.e., _immutable
CX contract_) which completely specifies the custom instructions and CSRs,
state, and behavior of a given composable custom extension. It is minted,
in a decentralized fashion, once and for all, by the designer of the
CX. If any facet of a CX is altered or extended, that is a different,
new CX, requiring a new CX UUID. (Thus a CX library, written and tested
to a given immutable CX, over the years will continue to observe the
same behavior from that specific CX.)

`cx_sel_t` is the type of a _CX selector_ value. A CX selector for a
given CX is obtained from `cx_open` and then used by `cx_select` to
select the CX instance prior to issuing its custom instructions.

`cx_open_flags_t` enumerates the `cx_open` options. `cx_open_shared`
indicates the specified CX should be opened _shared_; `cx_open_exclusive`
indicates the specified CX should be opened _exclusive_.

==== Functions

===== cx_sel_t cx_open(const uuid_t* puuid, cx_open_flags flags);

`cx_open` acquires a CX instance with the CX UUID `*puuid`, according
to open flags `flags`, if available, and returns the CX instance's
CX selector. On error `cx_open` returns `cx_sel_invalid` and `errno` is set.

ERRORS

* `EACCESS`: Permission to acquire the specified CX instance is denied.

* `EBUSY`: The CX instance is in use, perhaps try again later.

* `EFAULT`: `puuid` is outside your accessible address space.

* `EINVAL`: Invalid value in `flags`.

* `ENODEV`: No CX instance with the specified CX UUID exists on this system.

[NOTE]
====
The specific set of `cx_open` `errno` values depends upon the execution
environment.
====

Multiple _shared_ opens (on some thread) always obtain the same selector
value, whereas multiple _exclusive_ opens always obtain different
selector values.
```C
cx_sel_t sel_s0 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
cx_sel_t sel_s1 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
assert(!cx_valid(sel_s0) || !cx_valid(sel_s1) || sel_s0 == sel_s1);

cx_sel_t sel_x0 = cx_open(&your_exclusive_state_cx_uuid, cx_open_exclusive);
cx_sel_t sel_x1 = cx_open(&your_exclusive_state_cx_uuid, cx_open_exclusive);
assert(!cx_valid(sel_x0) || !cx_valid(sel_x1) || sel_x0 != sel_x1);
```

There is no guarantee, across successive open/close intervals, that
reopening a given CX will succeed, or will obtain the same selector value:
```C
cx_sel_t sel_s0 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
cx_sel_t sel_s1 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
assert(!cx_valid(sel_s0) || !cx_valid(sel_s1) || sel_s0 == sel_s1);
cx_close(sel_s0);
// shared CX instance is still in use
cx_close(sel_s1);
// shared CX instance is no longer in use
cx_sel_t sel_s2 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
cannot_assert(cx_valid(sel_s2)); // may fail
cannot_assert(sel_s0 == sel_s2); // may obtain a different selector value
```

In multithreading environments, CX instances, whether shared or exclusive,
are not shared across threads. So if thread 0 opens a shared CX instance,
and thread 1 opens a shared CX instance, these instances are disjoint
and isolated from each other. CX selector values are _scoped to the
thread_ upon which they were obtained via `cx_open` and have no meaning
within other threads. Opening a CX instance on one thread does not open
corresponding CX instances on other threads. Opening a CX instance on
one thread does not ensure the CX may also opened on other threads.
Two threads may open the same CX, whether shared or exclusive, and
receive different selector values. Two threads may open different CXs,
whether shared or exclusive, and receive identical selector values.

[NOTE]
====
`cx_open_ucontext` is a probationary (under consideration) _logical-or
option_, pertinent only to certain OS platforms and language runtimes,
that signals to the CX Runtime that this CX instance should participate in
user thread context save/restore behavior.
====

_Initialization_. A CX instance, opened or reopened for the first time,
is _initialized_ per the specification of the specific CX. (REVIEW)
A shared CX instance, opened for a second or subsequent time, is not
_initialized_.

===== int cx_close(cx_sel_t sel);

`cx_close` releases one reference to a CX instance. On last release of
a CX instance, the selector value becomes invalid. `cx_close` returns
0 on success. On error, -1 is returned, and `errno` is set.

ERRORS

* `EBADF`: `sel` isn't a valid CX selector.

[NOTE]
====
What is the best `errno` to indicate an invalid CX selector value
or a thread's current CX selection is invalid? Here `EBADF` is used,
reminiscent of an invalid file descriptor.
====

In multithreaded environments `cx_close` must be invoked on the same thread as
the corresponding `cx_open`. A CX instance that has been opened _shared_
`n` times on a thread must be closed `n` times.

On "last close", the thread's CX instance and related resources are
released.

===== bool cx_valid(cx_sel_t sel);

`cx_valid` returns `true` _iff_ the CX selector value indicates a
valid CX instance on this thread; an invalid, built-in, or stale (closed)
selector returns `false`.

===== cx_sel_t cx_get_sel(void);

`cx_get_sel` returns the thread's current CX selector value.

Each new thread starts with a current CX selector value of `cx_sel_builtin`.

===== cx_sel_t cx_select(cx_sel_t sel);

`cx_select` returns the thread's prior CX selection, and sets the thread's
current CX selection to the CX selector value argument.

When the current CX selector indicates a valid CX instance, custom
instructions and custom CSR accesses are performed by this CX instance;
when the selector is `cx_sel_builtin`, custom instructions and custom
CSR accesses are performed using the specific processor's pre-existing
built-in custom instructions; when the selector is invalid, including
`cx_sel_invalid`, custom instructions and custom instructions have
undefined behavior. In some environments, this behavior is defined to
signal an error condition.

===== ssize_t cx_save(void* pv, size_t size);

`cx_save` returns 0 if the current CX selection is `cx_sel_builtin`.

`cx_save` returns -1 and sets `errno` if the current CX selection is invalid.

`cx_save` with `pv == NULL` returns the number of bytes necessary to save
the CX instance state of the valid current CX selection, _which may be 0_.

`cx_save` with `pv != NULL` saves the CX instance state of the valid
current CX selection, up to but not to exceeding `size` bytes, at `*pv`,
and returns the number of bytes written. It returns -1 and sets `errno`
if `pv` is inaccessable.

ERRORS

* `EBADF`: The current CX selection is invalid.

* `EFAULT`: `pv` is outside your accessible address space.

===== ssize_t cx_restore(void* pv, size_t size);

`cx_restore` returns 0 if the current CX selection is `cx_sel_builtin`.

`cx_restore` returns -1 and sets `errno` if the current CX selection is invalid.

`cx_restore` with `pv == NULL` returns 0.

`cx_restore` with `pv != NULL` restores (reloads) the CX instance state
of the valid current CX selection, from the copy saved at `*pv`with
size `size` bytes. It returns the number of bytes read, which is always
less than or equal to `size`. It returns -1 and sets `errno` if `pv`
is inaccessable.

ERRORS

* `EBADF`: The current CX selection is invalid.

* `EFAULT`: `pv` is outside your accessible address space.

=== CX calling conventions

The CX calling conventions facilitate disciplined management of the
current CX selection and shared CX instances, enabling correct, safe
composition of legacy code that predates the CX Framework, and new code,
including code that uses built-in custom extensions as well as any number
of composable custom extensions.

There are two calling conventions:

1. Default calling convention: e.g. _legacy code_:

  a. On entry to callee, the current CX selection is
     `cx_sel_builtin`. (Caller ensures this.)

  b. On return from callee, the current CX selection is
     `cx_sel_builtin`. (Callee ensures this.)

  c. Shared CX instance state is _not_ preserved across function calls
     _(*caller* saved)_.

2. Optional CX calling convention: function attributed `riscv_cx_cc`:

  a. Callee preserves the caller's current selection _(callee saved)_.

  b. Shared CX instance state is preserved across function calls
     _(callee saved)_.

Initially a thread's current CX selection is `cx_sel_builtin`.

[NOTE]
====
The default calling convention ensures that a legacy function, perhaps
predating CX Framework, that issues the system's built-in custom
instructions, continues to do so, even if the legacy function is called
from CX library code.

Various ideas for this calling convention were previously explored in the
link:https://raw.githubusercontent.com/grayresearch/CX/main/spec/spec.pdf[CX Basis Spec] section
link:https://github.com/grayresearch/CX/blob/main/spec/cx-abi.adoc[CX-ABI].
====

=== CX library examples (non-normative)

These examples, of a dot product CX library employing two custom
instructions of a multiply-accumulate CX, illustrate how the various
CX state isolation models and calling conventions interact, for correct
composition, and what save/restore code might be necessary in hand-written
or CX-aware-compiler code generation.

Assume:
```C
#define CX_CALL __attribute__((riscv_cx_cc))

// external legacy function
int legacy_func(int);
// external CX-aware function
int cx_cc_func(int) CX_CALL;

inline static int mac_reset() CX_CALL {
//  return CUSTOM0_R(".insn r 0x0B, 0, 0", 0, 0);
    return CUSTOM0_R("mac_reset", 0, 0);
}
inline static int mac_mac(int a, int b) CX_CALL {
//  return CUSTOM_R(".insn r 0x0B, 0, 1", a, b);
    return CUSTOM0_R("mac_mac", a, b);
}
```

==== Exclusive state CX library -- CX CC -- no CX instance save/restore

```C
int dotp(cx_sel_t mac_sel, int as[], int bs[], unsigned n) CX_CALL {
    if (cx_valid(mac_sel)) {
        cx_sel_t prev = cx_select(mac_sel);

        int ret = mac_reset();
        for (int i = 0; i < n; ++i)
            ret = mac_mac(func_cx_cc(as[i]), bs[i]);

        cx_select(prev);
        return ret;
    }
    else
        return dotp_sw(as, bs, n);
}
```

==== Exclusive state CX library -- legacy CC -- no CX instance save/restore

Here `dotp` must set the current selection to `cx_sel_builtin` prior to
calling a legacy function, then restore `mac_sel`, prior to issuing
further CX custom instructions `mac_mac`.

```C
int dotp(cx_sel_t mac_sel, int as[], int bs[], unsigned n) {
    if (cx_valid(mac_sel)) {
        cx_sel_t prev = cx_select(mac_sel);
        int ret = mac_reset();

        for (int i = 0; i < n; ++i) {
            cx_select(cx_sel_builtin);
            int func_a_i = legacy_func(as[i]);
            cx_select(mac_sel);

            ret = mac_mac(func_a_i, bs[i]);
        }

        cx_select(prev);
        return ret;
    }
    else
        return dotp_sw(as, bs, n);
}
```

==== Shared state CX library -- CX calling convention -- CX instance save/restore

Here this _shared state_ CX `dotp` saves and restores _caller's_
CX instance state using the _CX-agnostic_ `cx_save` and `cx_restore`
APIs.

An alternative implementation might employ _CX-specific_ save/restore code
(for example, optimized to save only live registers across calls).

```C
int dotp(cx_sel_t mac_sel, int as[], int bs[], unsigned n) CX_CALL {
    if (cx_valid(mac_sel)) {
        cx_sel_t prev = cx_select(mac_sel);

        // save caller's MAC CX instance state
        size_t size = cx_save(0, 0);
        void* pv = alloca(size);
        cx_save(pv, size);

        // reset the state, perform the dot product
        int ret = mac_reset();
        for (int i = 0; i < n; ++i)
            ret = mac_mac(func_cx_cc(as[i]), bs[i]);

        // restore callee's CX state
        cx_restore(pv, size);

        cx_select(prev);
        return ret;
    }
    else
        return dotp_sw(as, bs, n);
}
```

==== Shared state CX library -- legacy CC -- CX instance save/restore

Here this shared state CX `dotp` saves and restores _its own_ MAC CX
instance state upon every call to an external legacy function. It also
selects `cx_sel_builtin` prior to each such call.

```C
int dotp(cx_sel_t mac_sel, int as[], int bs[], unsigned n) {
    if (cx_valid(mac_sel)) {
        cx_sel_t prev = cx_select(mac_sel);
        size_t size = cx_save(0, 0);
        void* pv = alloca(size);

        int ret = mac_reset();
        for (int i = 0; i < n; ++i) {
            cx_save(pv, size);
            cx_select(cx_sel_builtin);
            int func_a_i = legacy_func(as[i]);
            cx_select(mac_sel);
            cx_restore(pv, size);

            ret = mac_mac(func_a_i, bs[i]);
        }

        cx_select(prev);
        return ret;
    }
    else
        return dotp_sw(as, bs, n);
}
```

=== Extension versioning (non-normative)

"The only constant is change" wrote Heraclitus. Across decades,
instruction set extensions evolve and proliferate into family trees
of extensions.

Consider 20 years of x86 SIMD ISA extensions:
MMX (1997) added 64b integer MM0-7 registers (aliased x87 FPU registers) and SIMD;
SSE (1999) added 128b XMM0-7 registers and single precision FP SIMD;
SSE2 (2001) added double precision FP SIMD;
SSE3 (2004), SSSE3 (2006), and SSE4.x (2008) each added new operations;
AVX (2011) added 256b YMM0-15 registers and 256b FP SIMD;
AVX2 (2013) added 256b integer SIMD; and
AVX-512 (2016) added 512b ZMM0-31 registers (and 64b opmask registers) and 512b SIMD.
(Here, new SIMD registers overlap old, such that ZMM[5] contains YMM[5], which contains XMM[5].)

Similary there have been over a dozen major versions of the Microsoft
Direct3D API for high performance graphics. Change happens, and is tricky
to cope with after the fact, so dealing with change merits a sound,
uniform versioning strategy.

The CX Framework supports pervasive, dependable composition, including
composition of elements across _time and space_. A rich software
application, comprising _n_ separately authored and versioned CX
libraries, composed together, must run correctly on old and new systems,
which variously implement old and/or new versions of various CXs.

Each CX software library depends on specific CX(s)' behavior(s). _Any_
change, removing or adding any state or behavior, is potentially
disastrous. Therefore the CX Framework requires that CXs are immutable
and are identified for all time by UUIDs that may be burned into CX
software binaries.

==== CX version negotiation

When there are multiple versions of a CX, and various CX libraries that
each require certain CX versions, and various systems implementing
different subsets of CX versions, the CX programming model uses dynamic
discovery-powered _version negotiation_ to arrive at the best CX version
to use, by a given library, running on a given system. A CX library
will request (discover) its preferred CX. If not available, the library
may fall back, requesting another version of the CX, or some other
CX entirely. If necessary this may happen several times. Then, if no
acceptable CX, or another version of a CX, is discovered, the library
must fall back to pure software or issue an error.

Thus a CX library and a CX hardware implementation, developed by
different organizations in different decades can dynamically determine
the best, most up-to-date CX that's mutually supported by both of them
in the present system.

==== Versioning vs. shared or exclusive CX instance models

A consequence of this composable programming model, with version
negotiation, is that two CX libraries, separately authored, but running
on the same thread, may attempt to discover and use two different versions
of a CX.

This is a simple matter when a given CX supports an exclusive CX instance
model. Each CX library will receive its own exclusive CX instance of the
specific CX version it negotiated for. One library might use an instance
of an earlier CX version, with less instance state, another might use
a newer CX instance with more instance state. They do not interfere.

When a given CX supports a shared CX instance model, CX versioning is
more difficult. One CX library may discover and use an earlier version
of the CX, while another may discover and use a later version. As with
the x86 MMX...AVX example above, the CX instance state (e.g., extension
registers and CSRs) for the new CX version may be shared with the old
CX version, only if the state of the new version is a true superset of
the old version. If the new CX version adds some state _and removes some
state_, an instance of this new CX cannot be shared with a CX library
which requires the full state and behavior of the old CX.

For such a CX, such _breaking changes_ (to CX state or behavior) may
require a system to provide both a shareable old CX instance and a
disjoint shareable new CX instance to software.

Alternatively, discovering a shared instance of one version of such a
CX might cause subsequent discovery of other incompatible versions
to fail.

Also, in the true superset case, where a single shared CX instance
can be shared by CX libraries, old and new, CX-agnostic `cx_save` and
`cx_restore` APIs and user context support may insulate each library
from the complexities of its current extension's state's save/restore.

(It may not suffice for an MMX library to save/restore MMX0-7 registers,
when these are actually overlaid upon the ZMM0-31 registers that are
shared with other AVX libraries on the thread.)

==== Semantic versioning?

It has been proposed, not adopted, that the individual CXs of a family
tree of CX versions be identified by _semantic versioning_
link:https://semver.org[(semver.org)].

So instead of version negotiation by explicit discovery for, e.g.,
`MY_CX_v3_3_UUID`, then `MY_CX_v3_1_UUID`, then `MY_CX_v1_1_UUID`, a
CX library might discover for `(MY_CX_UUID,"3.2")` or `"3.2.8"`
and request the CX Runtime to discover the best (most recent?) CX
implemented on the present system.

Under semantic versioning, for a CX with a shared CX instance state
model, each new major CX version, by definition an _incompatible_ change,
would require a different shared CX instance.

Although CX API support for semantic versioning is appealing, as a
convenience facility, it introduces new problems. It can sometimes be
impossible to represent a series of CX versions in a linear timeline.
Sometimes an ISA extension's version family tree forks and forever
diverges. Sometimes it reconverges.

In the x86 MMX...AVX example, there have been different x86 processors
released with different supersets and subsets of AVX-2 and AVX-512
instructions. While this can be handled in extension-specific software,
e.g., walking a complex series of _CPUID_ discovery tables, in the CX
world the basic UUID discovery mechanism is necessary and sufficient.

==== Subsetting?

A common scenario will entail a system faithfully implementing some
proper _subset_ of a CX. Perhaps all CX state is implemented, but only a
subset of the CX's custom instructions. This is similar to the case of
the RISC-V `-M` (mul/div) extension which led to the subsequent RISC-V
`-Zmmul` (mul only) extension.

Should the CX API support discovery of such CX subsets, and how?

A CX library that discovers a CX may then use any of its custom
instructions. What happens when the library issues a custom instruction
that is not implemented? Silent corruption is not acceptable, whereas
an illegal instruction trap might be in some circumstances.

A simple and robust approach here is to treat any subset of a CX as a new
and different CX with a unique CX UUID. Then CX library software requires
only the subset behavior or state can explicitly discover for just that.

Furthermore, in a shared CX instance scenario, library A may discover and
use a CX instance for MY_CX_v2_3_UUID, whereas library B may discover
and use a CX instance for MY_CX_v3_1_SUBSET_XYZ_UUID. Here it might
still be possible to share one MY_CX_v3_1 instance between them.

==== Inspired by Microsoft Component Object Model (COM)

COM is Microsoft's framework for disciplined software component reuse, used across
hundreds of separately authored dynamic libraries, proven at industry
scale for over 30 years. See
link:https://learn.microsoft.com/en-us/windows/win32/com/the-component-object-model[The Component Object Model].
Like COM, the CX versioning strategy has these elements:

* Independently authored, immutable interface contracts (CXs), self-named by UUIDs
* Components (CXUs) implement one _or more_ interfaces (CXs), often different CX versions
* Across systems there may be different implementations (different CXUs) for a given interface (CX)
* Use dynamic discovery to find the best available interface (CX) to use _here_, a negotiation across time and space

=== Other TODOs (non-normative)

Revisit:

* `cx_uuid` vs. `cxid`
* `cxinfo`
* `cxsaveall`, `cxrestoreall`
* distinguishing `RISCV_CX_INFO_STATE_SIZE` vs `cx_save(0,0)` size
* `hwprobe` keys (Linux)
* `cxenable`, `cxdisable`

=== Implementation considerations (non-normative)

==== Linux

(TODO: detail how both shared and exclusive CX models live atop an OS that supports only one, or the other.)

==== System topology, virtual machines, dynamic hotplug, dynamic partial reconfiguration, revocation
