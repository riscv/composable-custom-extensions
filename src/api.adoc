[[cx_api]]
== CX API

[WARNING]
.This section is in the link:http://riscv.org/spec-state[Development state].
====
This section is actively being written and subsections and detail
are changing daily. Please check back regularly for updates.
====

=== Introduction (non-normative)

This section specifies the _CX API_ (application programming interface)
that _CX libraries_ use to discover, select, use, share, and manage
composable custom extensions.

The CX API is implemented, in each environment, by a _CX Runtime_,
typically in concert with a CX-aware operating system.

The API provides common, uniform CX programming services, including CX
naming, discovery, versioning, use, state models, error handling, and
resource management.

The CX API promotes a _CX programming model_ providing dependable
composition of CX libraries, decentralized development, and stable CX
library binaries, for modern software ecosystems and applications.

==== Foundational assumptions

The CX Framework supports independently authored and versioned CX
libraries.

CX libraries must support systems and hardware with and without any
given CX.

CX library _binaries_ are stable, meaning they need not be recompiled
for different systems that implement different sets of CXs.

CX libraries employ a dynamic discovery model, requesting access to one
or more CXs, and coping when the requested CX is not available, perhaps by
falling back to request a different CX or CX version, or by erroring out.

A given CX library employs a coding pattern of _discover_, _select_,
_use_. It first discovers (requests) a given CX. Then, if available,
it always selects a CX prior to issuing its custom instructions.

==== Other requirements and desiderata

Language and compiler support is optional: it must be possible to use a CX
and its CX libraries without changing the compiler / compilation system.

Similarly the CX programming model that the CX API promotes must make
it possible to add a new CX and its libraries to a system without having
to change the operating system / kernel / RTOS.

The CX API must support modern programming models including threads,
task parallel, async/await, and coroutine models.

The CX API must support arbitrary composition of CX libraries. Mutiple CX
libraries may use the same CX, and CX libraries may nest calls to other
CX libraries.

The CX API must promote longevity across decades, anticipate and support
forward compatibility, for arbitrary mixes of old and new CX libraries
running on old and new processors, with old and new versions of given
CXs. With long lived interop standards, and rich software ecosystems,
there can be no "just recompile everything" do-over.

The CX API should be as simple and minimalist as possible.

The CX API and programming model should promote efficient programming
idioms.

To promote source code portability of _purely computational_ CX libraries,
the CX API itself should not exhibit operating system dependencies.

==== CX state isolation models

Different CXs will be designed to exhibit different state isolation models.
The CX API supports at least three major categories of such models:

1. A _stateless_ CX requires no additional state. CX custom instructions
access only the pre-existing hart state.

2. A _shared state_ CX assumes there may be zero or one instance of CX
state per hart. Its custom instructions may access this state and their
behavior may depend upon it. It has a specific _sharing model_, uniformly
employed by its various (independenly authored) CX libraries, specifying
the discipline used by all such CX libraries to dependably share the one
instance of the CX state among them. For example, a CX's sharing model
might be caller-save, callee-save, always-initialize, or even something
finer grained that is specific to that CX's state.

3. An _exclusive state_ CX assumes there may be zero or more instances of
CX state per hart. Its custom instructions may access the one currently
selected instance state and their behavior may depend upon it. An
exclusive state CX library may rely upon its sole ownership of the CX
instance, and therefore need not save/restore its state across
invocations. (TODO: provide additional specificity on this.)

==== CX state isolation models vs. user thread context state

A subtle and important consideration (for some environments) is whether a
given CX instance is to be considered part of the _user_ thread context,
such that it is automatically saved by, e.g., the user C/C++ runtime
library in `setjmp's jmp_buf` structure, or in `makecontext's ucontext_t`
structure.

It is appealing to try to couple this behavior to the CX's state model,
e.g., shared state CXs are preserved in user thread contexts while
exclusive state CXs are _not_ -- but it may be useful to keep these
decoupled and orthogonal. Consider the four cases.

1. Shared state CX instance, included in user thread contexts: this
follows current practice for RISC-V extensions. (REVIEW: is this true
for -V vector state on Linux / glibc? -- is it automatically added to
`ucontext_t` upon use?)

2. Shared state CX instance, _not_ included in user thread contexts.
If a new shared state CX (e.g., an AME-like CX) has an enormous
memory footprint, it may be performance-prohibitive to include it in
user context records.

3. Exclusive state CX instance, _not_ included in user thread contexts.
This is the expected way to use a private state CX. It is treated as
an owned _hardware object_, much like another heap allocated object,
a private resource explicitly managed by the specific CX library.

4. Exclusive state CX instance, included in user thread contexts.
It is unclear if there is a compelling use case for this combination.

Distinguishing between case 1 and 2 seems useful, so this draft
specification supports decoupling these behaviors (see
`cx_open_ucontext` below).

==== User thread context includes the thread's current CX selection

Note the distinction between CX Framework state, i.e., thread's
_current CX (instance) selection_, and various CX instances' state.

The thread's current CX selection (see `cx_select` and `cx_get_sel` below),
is part of the user thread state. On Linux/glibc it is preserved in
user thread contexts objects, including `ucontext_t` and `jmp_buf`.

=== CX API

==== API

(TODO: Revise the entire API, below, for better error reporting.)

```C
#include <stddef.h>
#include <stdint.h>

typedef struct uuid_t {
    uint64_t high;
    uint64_t low;
} uuid_t;

typedef enum cx_sel_t {
    cx_sel_invalid  = -1,
    cx_sel_builtin  = 0,
    cx_sel_first_cx = 1
} cx_sel_t;

typedef enum cx_open_flags {
    cx_open_shared      = 0,
    cx_open_exclusive   = 1,
    cx_open_ucontext    = 2
} cx_open_flags;

cx_sel_t cx_open(const uuid_t* puuid, cx_open_flags flags);
void     cx_close(cx_sel_t sel);
bool     cx_sel_is_cx(cx_sel_t sel);
cx_sel_t cx_get_sel(void);
cx_sel_t cx_select(cx_sel_t sel);
size_t   cx_save(void* pv, size_t size);
void     cx_restore(void* pv, size_t size);
```

==== Types

`uuid_t` is a 128b _Universally Unique ID_ (RFC 9562). CX libraries
(esp. CX library binaries) employ CX UUIDs to canonically and stably
identify CXs across time and space.

A CX UUID is the unique and canonical name of a given CX (i.e., _immutable
CX contract_) which completely specifies the custom instructions and CSRs,
state, and behavior of a given composable custom extension. It is minted,
in a decentralized fashion, once and for all, by the designer of the
CX. If any facet of a CX is altered or extended, that is a different,
new CX, requiring a new CX UUID. (Thus a CX library, written and tested
to a given immutable CX, over the years will continue to observe the
same behavior from that specific CX.)

`cx_sel_t` is the type of a _CX selector_ value. A CX selector for a
given CX is obtained from `cx_open` and then used by `cx_select` to
select the CX instance prior to issuing its custom instructions.

`cx_open_flags` enumerates the `cx_open` options. `cx_open_shared`
indicates the specified CX should be opened _shared_; `cx_open_exclusive`
indicates the specified CX should be opened _exclusive_.

==== Functions

===== cx_sel_t cx_open(const uuid_t* puuid, cx_open_flags flags);

`cx_open` performs discovery and resource management of a CX instance. If
the CX identified by `*puuid` is present, available, and granted per
`cx_open_flags`, the CX instance is acquired (referenced), and `cx_open`
returns a valid CX selector value; otherwise `cx_sel_invalid`.

The selector value may then be used, upon the same thread, to select
the CX instance (`cx_select`) or to release the CX instance (`cx_close`).

Multiple _shared_ opens (on some thread) always obtain the same selector
value, whereas multiple _exclusive_ opens always obtain different
selector values.
```C++
cx_sel_t sel_s0 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
cx_sel_t sel_s1 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
assert(!cx_sel_is_cx(sel_s0) || !cx_sel_is_cx(sel_s1) || sel_s0 == sel_s1);

cx_sel_t sel_x0 = cx_open(&your_exclusive_state_cx_uuid, cx_open_exclusive);
cx_sel_t sel_x1 = cx_open(&your_exclusive_state_cx_uuid, cx_open_exclusive);
assert(!cx_sel_is_cx(sel_x0) || !cx_sel_is_cx(sel_x1) || sel_x0 != sel_x1);
```

There is no guarantee, across successive open/close intervals, that
reopening a given CX will succeed, or will obtain the same selector value:
```C++
cx_sel_t sel_s0 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
cx_sel_t sel_s1 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
assert(!cx_sel_is_cx(sel_s0) || !cx_sel_is_cx(sel_s1) || sel_s0 == sel_s1);
cx_close(sel_s0);
// shared CX instance is still in use
cx_close(sel_s1);
// shared CX instance is no longer in use
cx_sel_t sel_s2 = cx_open(&my_shared_state_cx_uuid, cx_open_shared);
cannot_assert(cx_sel_is_cx(sel_S2)); // may fail
cannot_assert(sel_s0 == sel_s2);     // may obtain a different selector value
```

In multhreading environments, CX instances, whether shared or exclusive,
are never shared across threads. So if thread 0 opens a shared CX
instance, and thread 1 opens a shared CX instance, these instances are
disjoint and isolated from each other. CX selector values are _scoped
to the thread_ upon which they were obtained via `cx_open` and have no
meaning within other threads. Opening a CX instance on one thread does not
open corresponding CX instances on other threads. Opening a CX instance
on one thread does not ensure the CX may also opened on other threads.
Two threads may open the same CX, whether shared or exclusive, and
receive different selector values. Two threads may open different CXs,
whether shared or exclusive, and receive identical selector values.

`cx_open_ucontext` is a probationary (under consideration) _logical-or
option_, pertinent only to certain OS platforms and language runtimes,
that signals to the CX Runtime that this CX instance should participate in
user thread context save/restore behavior.

_Initialization_. A CX instance, opened or reopened for the first time,
is _initialized_ per the specification of the specific CX. (REVIEW)
Note that a shared CX instance, opened for a second or subsequent time,
might not be _initialized_.

===== void cx_close(cx_sel_t sel);

`cx_close` releases one reference to a CX instance. The selector value
becomes invalid.

In multithreaded
environments it must be invoked on the same thread as the corresponding
`cx_open`. A CX instance that has been opened _shared_ `n` times on a
thread must be closed `n` times.

On "last close", the thread's CX instance and related resources are
released.

REVIEW: perhaps `cx_open` and `cx_close` should be named `cx_acquire`
and `cx_release`.

===== bool cx_sel_is_cx(cx_sel_t sel);

`cx_sel_is_cx` returns `true` iff the CX selector value indicates a
valid CX instance on this thread; an invalid, built-in, or stale (closed)
selector returns `false`.

===== cx_sel_t cx_get_sel(void);

Return the thread's current CX selector value. Each new thread starts
with a current CX selector value of `cx_sel_builtin`.

===== cx_sel_t cx_select(cx_sel_t sel);

`cx_select` returns the thread's prior CX selection, and sets the thread's
current CX selection to the CX selector value argument.

When the current CX selector indicates a valid CX instance, custom
instructions and custom CSR accesses are performed by this CX instance;
when the selector is `cx_sel_builtin`, custom instructions and custom
CSR accesses are performed using the specific processor's pre-existing
built-in custom instructions; when the selector is invalid, including
`cx_sel_invalid`, custom instructions and custom instructions have
undefined behavior. In some environments, this behavior is defined to
signal an error condition.

===== size_t cx_save(void* pv, size_t size);

`cx_save` with `pv == 0` returns the number of bytes necessary to save
the CX instance state of the thread's currently selected CX instance.

REVIEW: What happens if `!cx_sel_is_cx(cx_get_sel())`?

`cx_save` with `pv != 0` saves the CX instance state of the thread's
currently selected CX instance, up to but not to exceeding `size` bytes,
at `*pv`.

===== void cx_restore(void* pv, size_t size);

`cx_restore` with `pv == 0` does nothing.

`cx_save` with `pv != 0` restores (reloads) the CX instance state of the
thread's currently selected CX instance, from the copy saved at `*pv`
with size `size` bytes.

REVIEW: What happens if `!cx_sel_is_cx(cx_get_sel())`?

=== CX calling conventions

The CX calling conventions facilitate disciplined management of the current
CX selection and shared CX instances, enabling correct, safe composition
of legacy code that predates the CX Framework, and new code, including
code that uses built-in custom extensions as well as any number of
composable custom extensions.

There are two calling conventions:

1. Default calling convention: e.g. _legacy code_:

  a. The callee preserves the caller's current CX selection _(callee saved)_.

  b. Shared CX instance state is _not_ preserved across function calls _(*caller* saved)_.

  c. Callers ensure that on callee entry, the current CX selection is `cx_sel_builtin`.

2. Optional CX calling convention: function attributed `riscv_cx_cc`:

  a. The callee preserves the caller's current selection _(callee saved)_.

  b. Shared CX instance state is preserved across function calls _(callee saved)_.

Initially a thread's current CX selection is `cx_sel_builtin`.

[NOTE]
====
The default calling convention ensures that a legacy function, perhaps
predating CX Framework, that issues the system's built-in custom
instructions, continues to do so, even if the legacy function is called
from CX library code.

Various ideas for this calling convention were previously explored in the
link:https://raw.githubusercontent.com/grayresearch/CX/main/spec/spec.pdf[CX Basis Spec] section
link:https://github.com/grayresearch/CX/blob/main/spec/cx-abi.adoc[CX-ABI].
====

=== CX library examples (non-normative)

These examples, of a dotproduct CX library employing two custom
instructions of a multiply-accumulate CX, illustrate how the various
CX state isolation models and calling conventions interact, for correct
composition, and what save/restore code might be necessary in hand-written
or CX-aware-compiler code generation.

Assume:
```C++
#define CX_CALL __attribute__((riscv_cx_cc))

// external legacy function
int legacy_func(int);
// external CX-aware function
int cx_cc_func(int) CX_CALL;

inline static int cx_mac_reset() CX_CALL {
//  return CUSTOM0_R(".insn r 0x0B, 0, 0", 0, 0);
    return CUSTOM0_R("cx_mac_reset", 0, 0);
}
inline static int cx_mac_mac(int a, int b) CX_CALL {
//  return CUSTOM_R(".insn r 0x0B, 0, 1", a, b);
    return CUSTOM0_R("cx_mac_mac", a, b);
}
```

==== Exclusive state CX library -- CX CC -- no CX instance save/restore

```C++
int dotp(cx_sel_t cx_sel_mac, int as[], int bs[], unsigned n) CX_CALL {
    if (cx_sel_is_cx(cx_sel_mac)) {
        cx_sel_t prev = cx_select(cx_sel_mac);

        int ret = cx_mac_reset();
        for (int i = 0; i < n; ++i)
            ret = cx_mac_mac(func_cx_cc(as[i]), bs[i]);

        cx_select(prev);
        return ret;
    }
    else
        return dotp_sw(as, bs, n);
}
```

==== Exclusive state CX library -- legacy CC -- no CX instance save/restore

Here `dotp` must set the current selection to `cx_sel_builtin` prior to
calling a legacy function, then restore `cx_sel_mac`, prior to issuing
further CX custom instructions `cx_mac_mac`.

```C++
int dotp(cx_sel_t cx_sel_mac, int as[], int bs[], unsigned n) {
    if (cx_sel_is_cx(cx_sel_mac)) {
        cx_sel_t prev = cx_select(cx_sel_mac);
        int ret = cx_mac_reset();

        for (int i = 0; i < n; ++i) {
            cx_select(cx_sel_builtin);
            int func_a_i = legacy_func(as[i]);
            cx_select(cx_sel_mac);

            ret = cx_mac_mac(func_a_i, bs[i]);
        }

        cx_select(prev);
        return ret;
    }
    else
        return dotp_sw(as, bs, n);
}
```

==== Shared state CX library -- CX calling convention -- CX instance save/restore

Here this _shared state_ CX `dotp` saves and restores _caller's_
CX instance state using the _CX-agnostic_ `cx_save` and `cx_restore`
APIs.

An alternative implementation might employ _CX-specific_ save/restore code
(for example, optimized to save only live registers across calls).

```C++
int dotp(cx_sel_t cx_sel_mac, int as[], int bs[], unsigned n) CX_CALL {
    if (cx_sel_is_cx(cx_sel_mac)) {
        cx_sel_t prev = cx_select(cx_sel_mac);

        // save caller's MAC CX instance state
        size_t size = cx_save(0, 0);
        void* pv = alloca(size);
        cx_save(pv, size);

        // reset the state, perform the dot product
        int ret = cx_mac_reset();
        for (int i = 0; i < n; ++i)
            ret = cx_mac_mac(func_cx_cc(as[i]), bs[i]);

        // restore callee's CX state
        cx_restore(pv, size);

        cx_select(prev);
        return ret;
    }
    else
        return dotp_sw(as, bs, n);
}
```

==== Shared state CX library -- legacy CC -- CX instance save/restore

Here this shared state CX `dotp` saves and restores _it's own_ MAC CX
instance state upon every call to an external legacy function. It also
selects `cx_sel_builtin` prior to each such call.

```C++
int dotp(cx_sel_t cx_sel_mac, int as[], int bs[], unsigned n) {
    if (cx_sel_is_cx(cx_sel_mac)) {
        cx_sel_t prev = cx_select(cx_sel_mac);
        size_t size = cx_save(0, 0);
        void* pv = alloca(size);

        int ret = cx_mac_reset();
        for (int i = 0; i < n; ++i) {
            cx_save(pv, size);
            cx_select(cx_sel_builtin);
            int func_a_i = legacy_func(as[i]);
            cx_select(cx_sel_mac);
            cx_restore(pv, size);

            ret = cx_mac_mac(func_a_i, bs[i]);
        }

        cx_select(prev);
        return ret;
    }
    else
        return dotp_sw(as, bs, n);
}
```

=== Other TODOs (non-normative)

Revisit:

* `cx_uuid` vs. `cxid`
* `cxinfo`
* `cxsaveall`, `cxrestoreall`
* distinguishing `RISCV_CX_INFO_STATE_SIZE` vs `cx_save(0,0)` size
* `hwprobe` keys (Linux)
* `cxenable`, `cxdisable`

=== Implementation considerations (non-normative)

==== Linux

(TODO: detail how both shared and exclusive CX models live atop an OS that supports only one, or the other.)

==== System topology, virtual machines, dynamic hotplug, dynamic partial reconfiguration, revocation
