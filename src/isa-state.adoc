[[isa-state]]
:secnums:
== Unprivileged Extension State Context Management Extension

=== Introduction

Traditionally, each new stateful ISA extension requires new operating
system context switch code, user runtime code, and/or compiler support
to save, restore, and manage its particular new CSRs, register files,
tightly coupled memories, etc. across thread switches and/or across
function calls. This leads to increased costs, incompatible one-off
solutions, and inconsistent enablement of new extensions across
diverse software environments.

The extension state context management extension provides an extension
agnostic, _uniform_ way to initialize, manage, save, and restore the
state context of any composable custom extension.

It works with <<isa-cx-mux,CX multiplexing>>. The state context data
of the hart's _selected_ CX instance may be read or written, word by
word, via two new standard CSRs, `cxsidx` and `cxsdata`. The `cxsidx`
CSR specifies the index of the word of extension state context data
accessed by a read or write of the `cxsdata` CSR.

By zeroing `cxsidx` and performing a series of `cxsdata` reads/writes,
software may uniformly save/restore the selected extension's state
context data to/from an opaque state context blob in memory.

_All_ custom extension state is accessed with (`cxsidx`, `cxsdata`)
CSRs, specifically including any custom CSRs.

.New CX State Context Management CSRs
[cols="2,2,2,10"]
[%autowidth]
|===
| Address | Privilege | Name | Description

| 0xTBD | URW | `cxsidx`  | CX state index
| 0xTBD | URW | `cxsdata` | CX state data
|===

=== CX State Context Index (`cxsidx`)

The read-write WARL XLEN-wide CX state index CSR, `cxsidx` specifies the
index of the word of CX state context data to access via the `cxsdata`
CSR.

`cxsidx` can represent any valid index of the state context data of the
selected CX. `cxsidx` is undefined following `cxsetsel`.

Valid values for `cxsidx` are 0 through `size-1`, where `size` is the size,
in words, of the CX state context data of the selected custom extension.

[NOTE]
====
The state context size for a custom extension can be obtained through
a platform specific discovery mechanism.
====

[NOTE]
====
The state context size for a custom extension may vary, e.g., from system
to system.
====

[NOTE]
====
The state context size for a custom extension is constant during execution
on a given system.
====

[NOTE]
====
Alternative proposal: `cxsidx` can represent any valid index of the state
context data of _any_ implemented CX. `cxsidx` is unchanged following
`cxsetsel`.
====

[NOTE]
====
Writing an invalid index value to `cxsidx` may write a valid or invalid
legal value. For example a two bit `cxsidx` implementation suffices
for a CX with four words of state context data, and such a `cxsidx`
can only represent four legal values 0-3, all valid indices.
====

=== CX State Context Data (`cxsdata`)

The read-write WARL XLEN-wide CX state index CSR, `cxsdata` is used to
read and/or write one word of the selected CX's state context data.

When `cxsdata` is read (e.g., `csrrs rd,cxsdata,x0`), one word of the
selected CX state context data, at valid index `cxsidx` is written to
the destination register.

When `cxsdata` is written (e.g., `csrrw x0,cxsdata,rs1`), the source
value is written to one word of the selected CX state context data,
at valid index `cxsidx`.

When `cxsdata` is read and written (e.g., `csrrw rd,cxsdata,rs1`), both
effects occur.

[NOTE]
====
A `cxsdata` read-write access by a `csrrs` or `csrrc` variant sets or
clears bits of the indexed word of the selected CX state and writes the
original value to the destination register.
====

Following each `cxsdata` access, the value `cxsidx + 1` is written to
`cxsidx`.

Following read/write of the last word of the selected CX's state context
data, the value of `cxsidx` is undefined.

When `cxsel` is 0 or invalid, or when `cxsidx` is not a valid index of the
selected CX's state context data, read or write of `cxsdata` is undefined.

=== Example CX context switch (non-normative)

This code selects and swaps a CX state context with a previously saved
state context blob.

```assembly
;; a0: mycx selector
;; a1: address of CX state context blob
;; a2: address just past CX state context blob
    cxsel a0            ; select mycx
    csrw cxsidx,x0      ; zero cxsidx
loop:
    ld t0,(a1)          ; load a word
    csrrw t1,cxsdata,t0 ; swap (R/W) it
    sd t1,(a1)          ; save a word
    add a1,a1,8         ; next word of blob
    blt a1,a2,loop      ; do-while
```
