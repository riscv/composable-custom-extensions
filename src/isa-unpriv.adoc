[[isa-unpriv]]
:secnums:
== Unprivileged CX Multiplexing

The unprivileged Composable Custom Extensions Extension supports _CX
multiplexing_ of the custom instruction and custom CSR spaces, so that
multiple custom extensions (of arbitrary custom instructions and custom
CSRs) can coexist conflict-free within a system.

The extension supports a model in which software first _discovers_ and
_selects_ a hart's current CX prior to issuing its custom instructions
or accessing its custom CSRs (collectively _"CX instructions"_). These
CX instructions are then executed by the selected custom extension and
ignored by others.

=== CX Extension Programmer's Model

The CX Extension adds one unprivileged CSR (`cxsel`) and one unprivileged
instruction (`cxsetsel`) to a base RISC-V ISA.

.New CX selection CSR
[cols="2,2,2,2,10"]
[%autowidth]
|===
| Address | Privilege | Name   | Width (bits) | Description

| 0xTBD | URO | cxsel | XLEN | CX selector
|===

`cxsel` indicates the currently selected CX. It is _WARL_ and contains
a legal _CX selector_ value.

=== CX Selectors

A _CX selector value_ is an `XLEN`-bit value.
Legal selector value _types_ are _instance_, _builtin_, or _null_.
An _instance_ selector designates a specific CX instance granted to this hart.
A _builtin_ selector designates the hart's built-in custom extensions.
The selector value of `0` is a reserved _builtin_ selector.
A _null_ selector designates no custom extension.

NOTE: A CX selector may be _hart specific_.

=== CX Set Selector Instruction

TBD (but non-custom) 32-bit instruction `cxsetsel rd,rs1` atomically
swaps values in the `cxsel` CSR and integer registers.  It writes the
initial value of `x[rs1]` to `cxsel`, and if `rd` is not `x0` it writes
the initial value of `cxsel` to `x[rd]`.

When the initial value of `x[rs1]` is not a legal CX selector, `cxsetsel`
writes a null selector into `cxsel`.

NOTE: There is a proposal to support simultaneous selection of more than
one CX on a hart, for example, one for each of `custom-0/1/2/3`. This may
require multiple such CSRs, `cxsel0`, `cxsel1`, etc., and/or changes to
`cxsetsel`.

NOTE: TODO: specify any _universal_ CX selector invariants.  For example,
does this litmus test always hold: _are legal CX selector preserved when
writing and reading back `cxsel`_?:

----
 cxsetsel rs1  ;; assume x[rs1] is a legal CX selector value
 csrr rd,cxsel ;; x[rd] == x[rs1] ??
----

=== CX Multiplexing

The CX selector value in `cxsel` determines which specific CX instance
granted to this hart, or the built-in custom extensions, executes CX
instructions.

When `cxsel` is an instance selector, a CX instruction executes using
the selected CX instance.

When `cxsel` is a builtin selector, a CX instruction executes using the
hart's built-in custom extensions.

When `cxsel` is a null selector, a CX instruction raises an illegal
instruction exception.

NOTE: An execution environment may implement an absent CX instruction
via _invisible trap_ emulation.

=== Example of CX Multiplexing (non-normative)

----
 // cx_sel_t sel_A = cx_discover(CX_A_UUID, ...);
 // cx_sel_t sel_B = cx_discover(CX_B_UUID, ...);
 if (!cx_instance(sel_A) || !cx_instance(sel_B)) ...

 cxsetsel sel_A
 custom-0.func rd,rs1,rs2,...	// d = CX_A::af(s1, s2, ...);
 ...
 cxsetsel sel_B
 custom-0.func rd,rs1,rs2,...	// d = CX_B::bf(s1, s2, ...);
 ...
----
